# Modelo de negocio y especificación técnica completa

*(Plataforma para gestión segura de personas albergadas en refugios durante desastres — documento técnico para desarrollo por IA/equipo de ingeniería)*

---

## 1. Propósito y alcance

**Propósito:**
Crear una plataforma web segura, resiliente y auditada para registrar, gestionar y publicar información no sensible sobre personas albergadas en refugios durante desastres. La plataforma ofrece:

* Un **portal público** (landing) que muestra: propósito, métricas agregadas, catálogo de refugios, lista pública y buscable de personas albergadas (sin datos sensibles), descargas CSV/PDF y mapa.
* Un **panel privado** para operación (roles: Administrador, Refugio, Auditor) con controles de acceso estrictos.
* Importación masiva vía **CSV** con plantilla oficial.
* Auditoría completa y cumplimiento de buenas prácticas (NIST CSF, ISO 27000:2022, CIS Controls).

**Alcance funcional clave:** registro de personas por refugio, manejo de grupos/familias y relaciones, estadísticas y reportes, exportaciones, geolocalización del refugio, subida masiva verificada, y controles de seguridad y auditoría.

---

## 2. Principios de diseño e impuestos por cumplimiento

* **Privilegio mínimo:** toda interacción con datos de negocio se hace a través de *vistas* y *procedimientos almacenados*; la cuenta de la aplicación no tiene acceso directo a tablas base.
* **Separa lectura pública y privada:** vistas públicas con datos agregados y sensibles eliminados/omitidos; vistas privadas con más detalle restringidas por rol.
* **Defensa en profundidad:** validación y sanitización frontend + backend; prepared statements; CSP y escape en renderizado; validación de archivos.
* **Trazabilidad:** registro de auditoría para cada operación crítica (CREATE/UPDATE/DELETE/import).
* **Privacidad:** no almacenar DNI, teléfonos ni direcciones particulares de refugiados.
* **Disponibilidad y resiliencia:** backups, replicación, procedimientos de recuperación y tests de DRP.
* **Cumplimiento:** mapear controles a NIST CSF / ISO 27000 / CIS Controls (sección 11).

---

## 3. Diagrama lógico de datos (resumen ER)

Entidades principales:

* `Refugios` (refugio\_id)
* `Usuarios` (usuario\_id, rol, vinculado a refugio si rol=Refugio)
* `Personas` (persona\_id)
* `Grupos` (grupo\_id, jefe\_grupo\_id)
* `GrupoMiembros` (grupo\_id, persona\_id, relacion)
* `Salud` (salud\_id en 1:1 con persona)
* `Procedencia` (procedencia\_id 1:1)
* `RegistroRefugio` (registro\_id: relaciones persona-refugio y su estatus)
* `AuditLog` (log\_id, usuario, acción, tabla/vista, resumen, payload\_hash, timestamp)
* `BulkUploads` (upload\_id, refugio\_id, estado, mensaje\_validación)

Relaciones: Personas ↔ RegistroRefugio (1\:N), Personas ↔ Salud (1:1), Grupos ↔ GrupoMiembros (1\:N), Refugios ↔ RegistroRefugio (1\:N), Usuarios ↔ Refugios (0..1).

---

## 4. Esquema SQL (tablas principales — 3FN, con índices y buenas prácticas)

> Nota: uso `DATETIME` para trazabilidad, `utf8mb4` collation, índices para búsquedas y FK para integridad.

```sql
-- Refugios
CREATE TABLE Refugios (
    refugio_id INT AUTO_INCREMENT PRIMARY KEY,
    nombre_refugio VARCHAR(150) NOT NULL,
    ubicacion VARCHAR(200) NOT NULL,
    lat DECIMAL(9,6) NULL,
    lng DECIMAL(9,6) NULL,
    fecha_apertura DATE NOT NULL,
    capacidad_maxima INT NOT NULL,
    capacidad_ocupada INT NOT NULL DEFAULT 0,
    estado ENUM('Disponible','Completo') 
        AS (CASE WHEN capacidad_ocupada >= capacidad_maxima THEN 'Completo' ELSE 'Disponible' END) STORED,
    creado_en DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    actualizado_en DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE(nombre_refugio)
);
CREATE INDEX idx_refugios_estado ON Refugios(estado);

-- Usuarios
CREATE TABLE Usuarios (
    usuario_id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(100) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    rol ENUM('Administrador','Refugio','Auditor') NOT NULL,
    refugio_id INT NULL,
    nombre_mostrado VARCHAR(150) NOT NULL,
    creado_en DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    ultimo_login DATETIME NULL,
    FOREIGN KEY (refugio_id) REFERENCES Refugios(refugio_id) ON DELETE SET NULL
);
CREATE INDEX idx_usuarios_rol ON Usuarios(rol);

-- Personas
CREATE TABLE Personas (
    persona_id INT AUTO_INCREMENT PRIMARY KEY,
    nombre_preferido VARCHAR(150) NOT NULL,
    edad_rango ENUM('Niño/a','Adolescente','Adulto','Adulto mayor') NOT NULL,
    genero ENUM('F','M','Otro','Prefiere no decir') NOT NULL,
    idioma_principal VARCHAR(80) NULL,
    creado_en DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);
CREATE INDEX idx_personas_nombre ON Personas(nombre_preferido);

-- Grupos
CREATE TABLE Grupos (
    grupo_id INT AUTO_INCREMENT PRIMARY KEY,
    jefe_grupo_id INT NOT NULL,
    creado_en DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (jefe_grupo_id) REFERENCES Personas(persona_id) ON DELETE RESTRICT
);

-- GrupoMiembros
CREATE TABLE GrupoMiembros (
    grupo_id INT NOT NULL,
    persona_id INT NOT NULL,
    relacion ENUM('Jefe','Esposo/a','Hijo/a','Otro') NOT NULL,
    PRIMARY KEY (grupo_id, persona_id),
    FOREIGN KEY (grupo_id) REFERENCES Grupos(grupo_id) ON DELETE CASCADE,
    FOREIGN KEY (persona_id) REFERENCES Personas(persona_id) ON DELETE CASCADE
);

-- Salud (opcional por persona)
CREATE TABLE Salud (
    salud_id INT AUTO_INCREMENT PRIMARY KEY,
    persona_id INT NOT NULL UNIQUE,
    condicion_medica TEXT,
    medicamentos TEXT,
    alergias TEXT,
    asistencia_especial TEXT,
    FOREIGN KEY (persona_id) REFERENCES Personas(persona_id) ON DELETE CASCADE
);

-- Procedencia
CREATE TABLE Procedencia (
    procedencia_id INT AUTO_INCREMENT PRIMARY KEY,
    persona_id INT NOT NULL UNIQUE,
    localidad VARCHAR(120) NOT NULL,
    situacion ENUM('Vivienda perdida','Temporalmente desplazado') NOT NULL,
    tiene_mascotas BOOLEAN NOT NULL DEFAULT FALSE,
    mascotas_detalle TEXT,
    FOREIGN KEY (persona_id) REFERENCES Personas(persona_id) ON DELETE CASCADE
);

-- RegistroRefugio
CREATE TABLE RegistroRefugio (
    registro_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    persona_id INT NOT NULL,
    refugio_id INT NOT NULL,
    fecha_ingreso DATE NOT NULL,
    hora_ingreso TIME NOT NULL,
    area_asignada VARCHAR(80) NOT NULL,
    estatus ENUM('Alojado','Dado de alta','Trasladado a otro refugio') NOT NULL,
    observaciones TEXT,
    creado_en DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    actualizado_en DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (persona_id) REFERENCES Personas(persona_id) ON DELETE CASCADE,
    FOREIGN KEY (refugio_id) REFERENCES Refugios(refugio_id) ON DELETE CASCADE
);
CREATE INDEX idx_registro_estatus ON RegistroRefugio(estatus);
CREATE INDEX idx_registro_fecha ON RegistroRefugio(fecha_ingreso);

-- Auditoría
CREATE TABLE AuditLog (
    log_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    usuario_id INT NULL,
    rol VARCHAR(50) NULL,
    accion VARCHAR(50) NOT NULL, -- e.g., 'INSERT', 'UPDATE', 'DELETE', 'IMPORT'
    objeto VARCHAR(100) NOT NULL, -- nombre de tabla o vista
    objeto_id VARCHAR(100) NULL,
    resumen TEXT,
    payload_hash VARCHAR(128) NULL,
    ip_origen VARCHAR(45) NULL,
    user_agent TEXT NULL,
    creado_en DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (usuario_id) REFERENCES Usuarios(usuario_id) ON DELETE SET NULL
);

-- BulkUploads
CREATE TABLE BulkUploads (
    upload_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    refugio_id INT NOT NULL,
    filename VARCHAR(255) NOT NULL,
    estado ENUM('Pendiente','Validado','Fallido','Procesado') NOT NULL DEFAULT 'Pendiente',
    mensaje TEXT NULL,
    creado_en DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    procesado_en DATETIME NULL,
    FOREIGN KEY (refugio_id) REFERENCES Refugios(refugio_id) ON DELETE CASCADE
);
```

---

## 5. Vistas (obligatorio: todo acceso es por vistas)

### Vistas públicas (sin login)

* `vw_public_personas` — lista de personas *actualmente alojadas* con los campos expuestos públicamente.
* `vw_public_estadisticas` — métricas agregadas globales.
* `vw_public_refugios` — catálogo de refugios con indicadores y coordenadas.

Ejemplo `vw_public_personas`:

```sql
CREATE VIEW vw_public_personas AS
SELECT 
  p.persona_id,
  p.nombre_preferido AS nombre,
  rr.estatus,
  rr.fecha_ingreso,
  rr.hora_ingreso,
  r.nombre_refugio AS refugio,
  r.ubicacion AS direccion
FROM RegistroRefugio rr
JOIN Personas p ON rr.persona_id = p.persona_id
JOIN Refugios r ON rr.refugio_id = r.refugio_id
WHERE rr.estatus = 'Alojado';
```

Ejemplo `vw_public_estadisticas`:

```sql
CREATE VIEW vw_public_estadisticas AS
SELECT 
  COUNT(*) AS total_personas,
  SUM(CASE WHEN estatus='Alojado' THEN 1 ELSE 0 END) AS total_alojados,
  SUM(CASE WHEN estatus='Dado de alta' THEN 1 ELSE 0 END) AS total_dados_alta,
  SUM(CASE WHEN estatus='Trasladado a otro refugio' THEN 1 ELSE 0 END) AS total_trasladados
FROM RegistroRefugio;
```

### Vistas privadas (role-based)

* `vw_refugio_personas` — filtra por `refugio_id` (el usuario de la aplicación pasa el claim/refugio\_id).
* `vw_admin_personas_full` — incluye campos administrativos y joins (solo para Administrador).
* `vw_auditor_activity` — actividades registradas para auditoría (solo lectura).

> Implementar vistas parametrizadas a nivel de aplicación: la app hace `SELECT * FROM vw_refugio_personas WHERE refugio_id = ?` o se crean vistas específicas por refugio si lo exige el motor DB y permisos.

---

## 6. Procedimientos almacenados y triggers (control de integridad y actualizaciones de capacidad)

**Regla:** los inserts/updates/deletes de `RegistroRefugio` se realizan mediante stored procedures que validan, auditan y actualizan `Refugios.capacidad_ocupada`.

Ejemplo de procedimiento para crear un registro y actualizar capacidad:

```sql
DELIMITER //
CREATE PROCEDURE sp_registrar_ingreso(
    IN p_persona_id INT,
    IN p_refugio_id INT,
    IN p_fecha_ingreso DATE,
    IN p_hora_ingreso TIME,
    IN p_area VARCHAR(80),
    IN p_estatus ENUM('Alojado','Dado de alta','Trasladado a otro refugio'),
    IN p_observaciones TEXT,
    IN p_usuario_id INT
)
BEGIN
    DECLARE v_cap_actual INT;
    DECLARE v_cap_max INT;
    START TRANSACTION;
    SELECT capacidad_ocupada, capacidad_maxima INTO v_cap_actual, v_cap_max
      FROM Refugios WHERE refugio_id = p_refugio_id FOR UPDATE;

    IF p_estatus = 'Alojado' AND v_cap_actual >= v_cap_max THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Refugio sin capacidad';
    ELSE
        INSERT INTO RegistroRefugio(persona_id, refugio_id, fecha_ingreso, hora_ingreso, area_asignada, estatus, observaciones)
        VALUES (p_persona_id, p_refugio_id, p_fecha_ingreso, p_hora_ingreso, p_area, p_estatus, p_observaciones);

        IF p_estatus = 'Alojado' THEN
            UPDATE Refugios SET capacidad_ocupada = capacidad_ocupada + 1 WHERE refugio_id = p_refugio_id;
        END IF;
        
        -- auditoría
        INSERT INTO AuditLog(usuario_id, rol, accion, objeto, objeto_id, resumen, ip_origen)
        VALUES (p_usuario_id, NULL, 'INSERT', 'RegistroRefugio', LAST_INSERT_ID(), CONCAT('Ingreso de persona ', p_persona_id, ' en refugio ', p_refugio_id), NULL);
    END IF;

    COMMIT;
END //
DELIMITER ;
```

Procedimientos similares para `sp_actualizar_estatus_registro` (que decrementa o incrementa `capacidad_ocupada` según transición de estatus) y para procesar **bulk CSV** (validación, dry-run, insert por batches, logs de errores).

---

## 7. Plantilla CSV (orden y validación)

**IMPORTANTE:** La plataforma interpreta el CSV en el siguiente **orden de columnas** (obligatorio):

1. `nombre_preferido` (string, obligatorio)
2. `edad_rango` (uno de: 'Niño/a','Adolescente','Adulto','Adulto mayor')
3. `genero` (uno de: 'F','M','Otro','Prefiere no decir')
4. `idioma_principal` (string o vacío)
5. `grupo_jefe` (boolean: TRUE/FALSE o 'si'/'no') — si la persona es jefe de grupo
6. `grupo_id_externo` (string) — identificador externo de grupo para correlacionar miembros antes de crear grupo en DB (opcional)
7. `relacion_con_jefe` (si aplica: 'Esposo/a','Hijo/a','Otro' o vacío)
8. `condicion_medica` (texto corto o vacío)
9. `medicamentos` (texto corto o vacío)
10. `alergias` (texto corto o vacío)
11. `asistencia_especial` (texto corto o vacío)
12. `localidad` (string)
13. `situacion` ('Vivienda perdida'|'Temporalmente desplazado')
14. `tiene_mascotas` (TRUE/FALSE)
15. `mascotas_detalle` (texto)
16. `fecha_ingreso` (YYYY-MM-DD)
17. `hora_ingreso` (HH\:MM\:SS)
18. `area_asignada` (string)
19. `estatus` ('Alojado'|'Dado de alta'|'Trasladado a otro refugio')

**Validaciones a aplicar (backend):**

* Cabeceras exactas y en el orden definido.
* Tipos y enumerados válidos.
* Campos fecha/hora parseables.
* Longitud de strings (no más de 1024 para campos libres).
* Límite de filas por upload (ej. 5.000 filas por carga).
* Rechazar archivos con contenido binario o MIME type incorrecto.
* Virus scan (antivirus) en el archivo antes del procesamiento.

**Flujo de importación:**

1. Usuario sube CSV → se guarda en `BulkUploads` con `estado = Pendiente`.
2. Worker valida cabeceras y realiza *dry-run* (validación de cada fila); reporta errores por fila.
3. Si validación OK → `estado = Validado`, se programa procesamiento en batch: por cada fila llamar `sp_registrar_ingreso`.
4. Si errores → `estado = Fallido` con `mensaje` que contiene resumen y link al reporte de errores.
5. Al finalizar → `estado = Procesado`, registrar `procesado_en` y auditoría.

---

## 8. API: contrato y endpoints (RESTful, JSON)

**Autenticación:** JWT con claims `usuario_id`, `rol`, `refugio_id`; tokens firmados con RSA (asymmetric) y expiración corta (p. ej. 1h) + refresh tokens rotativos.

**Encabezados:** `Authorization: Bearer <token>`, `X-Request-ID` (UUID) para correlación.

### Endpoints públicos (no auth)

* `GET /public/landing` — contenido del hero y textos.
* `GET /public/personas?search=&refugio=&page=&per_page=` — lista paginada desde `vw_public_personas`.
* `GET /public/statistics` — `vw_public_estadisticas`.
* `GET /public/refugios?search=&page=&per_page=` — `vw_public_refugios`.
* `GET /public/refugios/{id}/download?format=csv|pdf` — descarga export de personas alojadas (*rate limited, captchas opcionales*).
* `GET /public/refugios/{id}/map` — return lat/lng para embebido Google Maps.

### Endpoints panel (requieren JWT, roles)

* **Administración (rol=Administrador)**

  * `POST /admin/refugios` — crear refugio.
  * `PUT /admin/refugios/{id}` — actualizar (solo via stored procedures).
  * `DELETE /admin/refugios/{id}` — eliminar (soft-delete preferido).
  * `GET /admin/users` — listar usuarios.
  * `POST /admin/users` — crear usuario.
* **Refugio (rol=Refugio)**

  * `GET /refugio/personas` — lista del refugio (desde `vw_refugio_personas`).
  * `POST /refugio/personas` — registrar persona (payload validado y la app llama `sp_registrar_ingreso`).
  * `POST /refugio/upload-csv` — subir CSV (crea BulkUploads y dispara validación).
  * `PUT /refugio/profile` — actualizar nombre\_mostrado o contraseña (seguridad: reauth needed).
  * `POST /refugio/geolocate` — recibe lat/lng y reverse-geocoding para actualizar `Refugios.lat/lng` (procedimiento protegido).
* **Auditor (rol=Auditor)**

  * `GET /auditor/logs` — paginado desde `AuditLog`.
  * `GET /auditor/reports` — reportes agregados desde vistas admin.

**Responses:** estándar JSON API, con `meta` para paginación y `data` como array.

---

## 9. Frontend: landing page y paneles (UX/UI especificaciones)

### Landing page (public)

* **Hero**: Título claro, subtítulo con propósito, CTA primario: "Ver refugios" y CTA secundario: "Descargar estadísticas".
* **Secciones**:

  1. **Hero + misión** con imagen ilustrativa o fondo SVG.
  2. **Estatus globales** — tarjetas con números: total personas, alojados, dados de alta, trasladados.
  3. **Buscador de personas (dinámico)** — input con *debounce* (300ms), auto-suggest; mostrar tabla con columnas: `Nombre`, `Estatus`, `Fecha de Ingreso`, `Hora de Ingreso`, `Refugio`, `Ubicación`. Soporta paginación y sorting por fecha.
  4. **Catálogo de refugios** — grid/lista, cada card tiene: nombre, direccion (link a maps), botón `Descargar CSV`, indicador `Alojados`, `Dados de alta`, `Fecha apertura`. Filtrado dinámico independiente.
  5. **Mapa** con markers (cluster si muchos refugios); click en marker abre modal con resumen y botones (CSV/PDF).
  6. **Footer** — contactos institucionales, políticas de privacidad.

**Comportamiento de búsqueda dinámica:**

* Frontend mantiene dos búsquedas independientes: `searchPersonas` y `searchRefugios`.
* Debounce 300ms, cuando teclea llama a endpoints públicos paginados con `search` param; el backend aplica `LIKE` con índices e insiste en prepared statements.
* Mostrar sugerencias instantáneas (typeahead) opcional: consultar endpoint `GET /public/suggest?type=person|refugio&q=...`.

### Panel privado (Refugio / Admin / Auditor)

* Dashboard con widgets según rol.
* Formulario de ingreso rápido: campos mínimos y botón `Registrar` que llama al endpoint protegido.
* CSV upload UI con vista previa de primeras 10 filas y reporte de validación antes de procesar.
* Botón `Obtener ubicación actual` en la sección de refugio: solicita permiso del navegador (`navigator.geolocation.getCurrentPosition`) y llama `POST /refugio/geolocate` con lat/lng; backend hace reverse geocoding (opcional usar service externo) y guarda coordenadas en `Refugios`.

**Accesibilidad:** WCAG AA, móvil-first.

---

## 10. Seguridad (detallado técnico)

### Entrada y validación

* **Frontend:** escaping de salida (escape variables al renderizar), CSP headers, SRI para recursos, uso de React/Vue con binding seguro.
* **Backend:** validación por esquema (ej. JSON Schema) y sanitización. Uso de prepared statements o llamadas a stored procedures. Límite de tamaño de payload.
* **CSV:** validación estricta de cabeceras y tipos; reject on mismatch.

### Prevención de ataques

* **SQL Injection:** ninguna consulta concatenada; solo prepared statements + procedures + vistas. DB user application limitado a `EXECUTE` sobre procedures y `SELECT` en vistas necesarias.
* **XSS:** escapar siempre datos en HTML, usar CSP y HTTPOnly cookies para tokens (si se usan cookies).
* **CSRF:** tokens CSRF en forms si se usa cookie-based auth; con JWT en Authorization header, CSRF mitigado.
* **LFI/RFI:** validar paths de archivos, no permitir subida de archivos con nombres peligrosos, sandboxing y almacenamiento fuera de webroot.
* **File uploads:** check MIME type, parse/validate CSV structure, virus scan, almacenamiento en S3/obj storage con políticas de acceso.
* **Rate limiting:** IP-based y per-endpoint (ej. downloads), y límite de reintentos login.
* **Account security:** contraseñas con Argon2id; password policy; MFA para admins (OTP).
* **Session Management:** short-lived tokens + rotating refresh tokens; store refresh tokens hashed.
* **Transport:** TLS 1.2+ for all traffic; HSTS header.

### DB security

* Segregar cuentas:

  * `app_readonly` — solo SELECT en vistas públicas.
  * `app_refugio` — EXECUTE en procedures y SELECT en vistas del refugio.
  * `admin_db` — permisos ampliados.
* Encriptación at-rest: discos cifrados; si datos sensibles existieran, cifrado a nivel de campo (AES) con KMS.
* Backups cifrados y gestión de claves (KMS).

---

## 11. Auditoría, logs y monitoreo

* **AuditLog** tabla con entradas de cada operación crítica. No almacenar datos sensibles literales en logs; guardar hash si es necesario (payload\_hash).
* **Access logs** (nginx/app) y **application logs** (structured JSON) enviados a central (ELK or Loki).
* **Monitoring:** métricas de salud app + DB, uso CPU/mem, endpoints errores. Sugerencia: Prometheus + Grafana.
* **Alerting:** alertas para picos de error, reprocesos CSV fallidos, refugio alcanzando 80%/95% capacidad.
* **Retention:** logs de auditoría retenidos según política (p. ej. 2 años), backups retención configurable (diario, semanal, mensual).

---

## 12. Backups y recuperación

* **Backups diarios** completos + binlogs para PITR (point-in-time recovery).
* **Pruebas de DR** trimestrales.
* **Procedimiento de emergencia:** playbook con pasos para restaurar DB a T0-1h, comunicar stakeholders, y conmutación de DNS/LoadBalancers.

---

## 13. CI/CD y despliegue

* **Repositorios:** separaciones `frontend/`, `backend/`, `infra/` (IaC).
* **CI:** linters, tests unitarios, security static analysis (SAST), scan dependencies.
* **CD:** pipelines que despliegan a entornos `dev -> staging -> prod` con approval manual para prod.
* **IaC:** Terraform/CloudFormation para infra, K8s manifests via Helm.
* **Secrets:** gestionados por Vault o secret manager del cloud (no en repo).
* **Rollback:** capabilidad de revertir release.

---

## 14. Testing (calidad)

* **Unit tests**: 80%+ coverage en servicios críticos.
* **Integration tests**: endpoints, DB (use test DB).
* **E2E tests**: flujos de registro, CSV import, descargas.
* **Security testing:** SCA (Software Composition Analysis), SAST y DAST (app scanner), pruebas de penetración anuales.
* **Performance testing:** carga simulando picos (import masivo, búsquedas públicas).

---

## 15. Mapeo a frameworks de seguridad (resumen)

* **NIST CSF**: Identify (inventory refugios), Protect (auth, encryption), Detect (logs/monitoring), Respond (playbooks), Recover (backups/DR).
* **ISO 27000:2022**: controles de gestión, continuidad, control de acceso, criptografía, seguridad física/ambiental (si aplica).
* **CIS Controls**: inventario, configuración segura, gestión de vulnerabilidades, logging, control de acceso, MFA y protección de datos.

(Incluir en propuesta una tabla de mapeo detallada por control durante la fase de auditoría/compliance.)

---

## 16. Implementación práctica: checklist mínimo para el programador (priorizado)

1. **Infra & DB**

   * Instalar DB (gestión preferida: Cloud SQL o cluster gestionado).
   * Crear schema y objetos (tablas + vistas + procedures).
   * Crear cuentas DB con privilegio mínimo.
2. **Backend**

   * Implementar capa de servicio que solo invoque stored procedures y consuma vistas.
   * Implementar JWT auth y roles.
   * Implementar endpoints públicos y privados según contrato.
   * Implementar validación JSON Schema y CSV parser robusto.
3. **Frontend**

   * Landing page: hero, stats, buscadores (personas/refugios separados), mapa, cards de refugio.
   * Panel privado: formularios, carga CSV, geolocation button.
   * Implementar debounce/search, pagination, and export buttons.
4. **Seguridad**

   * Preparar CSP, helmet headers, HTTPS, X-Frame-Options.
   * Harden DB and app configs.
   * Implementar audit logging calls a `insert into AuditLog`.
5. **Bulk & Worker**

   * Worker asyncrónico (queue) para procesar CSV en background.
   * Reintentos y dead-letter queue para filas que fallan.
6. **Testing & CI/CD**

   * Pipelines que ejecuten tests y análisis de seguridad.
7. **Monitoring**

   * Prometheus exporters, Grafana dashboards, alerting rules.
8. **Docs**

   * API spec (OpenAPI/Swagger), DB schema doc, runbook de incidentes.

---

## 17. Ejemplos prácticos útiles para el programador

### Ejemplo: Endpoint `POST /refugio/upload-csv`

* **Auth:** JWT rol=Refugio
* **Payload:** multipart/form-data con `file` y `request_id`
* **Flow:**

  1. Auth check → store file in object storage (temp).
  2. Insert row en `BulkUploads` (estado Pendiente).
  3. Push job a worker queue.
  4. Worker valida cabeceras y contenido → genera `validation_report` (JSON).
  5. Si OK → call stored proc por batch para insertar y actualizar `Refugios.capacidad_ocupada`.
  6. Insert hits en `AuditLog`.
  7. Notificar por UI y email (opcional).

### Ejemplo: búsqueda dinámica (frontend)

* Input con debounce 300ms → fetch `GET /public/personas?search=ana&page=1`.
* Backend hace: `SELECT ... FROM vw_public_personas WHERE nombre LIKE ? OR refugio LIKE ? LIMIT 50` usando prepared statement.

---

## 18. Consideraciones de privacidad y gobernanza

* **Política de datos:** especificar retención (ej. datos conservados por X años), acceso y borrado bajo solicitud.
* **Minimización:** no almacenar identificadores personales sensibles; en caso de necesitarse almacenar para reunificación, cifrar y accesible solo a admins con MFA.
* **Transparencia:** landing incluir política de privacidad y contacto de responsable de protección de datos.

---

## 19. Roadmap de entrega (sugerencia)

1. MVP (4–6 semanas)

   * DB schema + vistas + procs básicos.
   * Landing minimal público con lista y buscador.
   * Panel refugio con registrar persona manual + CSV upload básico.
   * Auth y roles básicos.
2. Fase 2 (6–8 semanas)

   * Worker robusto, validación CSV completa, export PDF.
   * Auditoría y logs.
   * Geolocation y map integration.
3. Fase 3 (ongoing)

   * Hardening, compliance audit, DR tests, performance tuning, multi-region deploy.

---

## 20. Entregables para la propuesta (qué incluir al presentar)

* Documento técnico (este).
* Diagrama ER y diagramas de flujo (landing, panel, proceso CSV).
* Especificación API (OpenAPI).
* SQL scripts: schema + vistas + procedures + sample data.
* Wireframes de landing y panel (desktop + mobile).
* Plan de seguridad y checklist de cumplimiento.
* Costeo estimado (infra y mantenimiento).
* Timeline y milestones.

---

### Comentario final

Este documento es una especificación detallada pensada para que una **IA o equipo de desarrolladores** pueda implementar la plataforma con criterios claros: seguridad por diseño, separación de responsabilidades, y cumplimiento de normas. Puedo ahora generar automáticamente los **scripts SQL completos**, el **OpenAPI** para los endpoints descritos, los **wireframes** HTML/CSS del landing y del panel, o un **diagrama ER** listo para MySQL Workbench — dime cuál de esos entregables quieres primero y lo preparo.
